#### cookie

> 可以实现每次HTTP请求都自动带数据给服务器的技术

##### cookie基本流程

游览器发起HTTP请求 `=>` 服务器进行Cookie设置（set-cookie）cookie里有名和值两个重要属性，服务器会把名和值属性里的内容给填充完整，cookie发给游览器以后，游览器会保存起来，这样游览器以后发送的每一个请求都会自动附上这个cookie，

**cookie**就是一种存储在游览器的数据，我们也可在游览器看到我们保存的cookie，那么把用户名和密码放在cookie那么就不安全了，为了解决这个问题，就有了session 会话 其实我们可以把游览器和服务器的交互看成一次会话，游览器第一次访问服务器就是会话的开始，对于结束时间，是看具体网站对每用户的会话设定（设定的时间以及唯一的ID）

**服务器在发送cookie之前是会对这个含有Session ID的Cookie进行签名** 

当cookie失效后，游览器会自行删除这个cookie 会话结束

###### 当在同一时间大量用户访问一个服务器，那么就会产生很多sesssionID在服务器中，服务器就需要大量内存来存储，如果这个工作多台服务器来完成，那么就会产生一台服务器存储的sessionID其他服务器也需要使用，那么就需要把sessionID分享出去，因为可能出现这个服务器超载，需要分配一些用户到其他服务器，那么其他服务器需要通用的sessionID才可以避免用户再次输入用户名和密码，于是就想用专门的数据库来存储sessionID,但是又会出现数据库崩溃的情况，

然后JST（JSON Web Token） 

用户第一次登录网页

服务器生成一个JWT  服务器不需要保存JWT, 只需要保存JWT签名的密文

把JWT发给游览器，可以让游览器以cookie或者storage的形式进行存储

例如以cookie形式存储 这样用户每次发送请求都会把这个JWT发送给服务器，用户也就不需要重新输入用户密码 和session类似， 只是这里的token存储在用户（客户端）

##### JWT组成（安全）

> header.payload.signature

- header : 声明需要用什么算法来生成签名
- payload ： 一些特定的数据，例如有效期等等

> header和payload两部分的内容会经由base64编码，JWT存于客户端，服务器需要保存一段密码 服务器的密码结合两段编码进行算法（header声明的算法）运算 ==》》得到签名信息（signature部分）